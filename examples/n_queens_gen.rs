#[macro_use]
extern crate clap;

use std::fs::File;
use std::io;
use std::io::Write;
use std::io::*;

fn main() -> io::Result<()> {
    let args = clap_app!(QueenGenerator =>
        (version: "0.1")
        (author: "Tim Beurskens")
        (about: "Generates n-queen formulae for the SAT solver")
        (@arg queens: -n --queens +takes_value "The number of queens")
        (@arg output: -o --output +takes_value "The output file")
    )
    .get_matches();

    let n = args
        .value_of("queens")
        .expect("No number of queens specified")
        .parse::<usize>()
        .expect("Invalid number of queens");
    let output = args.value_of("output").expect("No output file specified");

    let mut f = File::create(output)?;
    let mut writer = BufWriter::new(f);

    writeln!(writer, "\"Generated by n-queens-gen {}\"", n)?;
    writeln!(writer)?;

    writeln!(
        writer,
        "\"every diagonal must contain at most one queen (direction 1)\""
    )?;

    for i in 0..n {
        write!(writer, "[")?;
        for j in 0..(n - i) {
            write!(writer, "v_{},", i + (j * (n + 1)))?;
        }
        writeln!(writer, "] <= 1 &")?;
    }

    writeln!(writer)?;

    for i in 1..n {
        write!(writer, "[")?;
        for j in 0..(n - i) {
            write!(writer, "v_{},", (i * n) + (j * (n + 1)))?;
        }
        writeln!(writer, "] <= 1 &")?;
    }

    writeln!(writer)?;
    writeln!(
        writer,
        "\"every diagonal must contain at most one queen (direction 2)\""
    )?;

    for i in 0..n {
        write!(writer, "[")?;
        for j in 0..=i {
            write!(writer, "v_{},", i + (j * (n - 1)))?;
        }
        writeln!(writer, "] <= 1 &")?;
    }

    writeln!(writer)?;

    // 15 = n * n - 1
    // 11 = n * (n-1) - 1 ; 14 = n * n - 2
    // 7 = n * (n-2) - 1 ; 10 = n * (n-1) - 2 ; 13 = n * n - 3
    for i in 1..n {
        write!(writer, "[")?;
        for j in 0..i {
            write!(writer, "v_{},", n * (n - j) - (i - j))?;
        }
        writeln!(writer, "] <= 1 &")?;
    }

    writeln!(writer)?;

    writeln!(writer, "\"every row must contain exactly one queen\"")?;

    for i in 0..n {
        write!(writer, "[")?;
        for j in 0..n {
            write!(writer, "v_{},", j + i * n)?;
        }
        writeln!(writer, "] = 1 &")?;
    }

    writeln!(writer)?;
    writeln!(writer, "\"every column must contain exactly one queen\"")?;

    for i in 0..n {
        write!(writer, "[")?;
        for j in 0..n {
            write!(writer, "v_{},", i + j * n)?;
        }
        writeln!(writer, "] = 1 &")?;
    }

    writeln!(writer)?;

    writeln!(writer, "\"end\"")?;
    writeln!(writer, "true")?;

    // flush the writer before dropping it
    writer.flush();

    Ok(())

    // // skip the first, as this is already covered by the previous expression
    // let diag_expr_vr = (1..n)
    //     .map(|i| {
    //         (0..=i)
    //             .map(|j| e.var((i * n) + (j * (n - 1))))
    //             .collect::<Vec<_>>()
    //     })
    //     .map(|ref c| e.amn(c, 1))
    //     .fold(e.mk_const(true), |ref acc, ref k| {
    //         e.and(Rc::clone(acc), Rc::clone(k))
    //     });
}
