#[macro_use]
extern crate clap;

use std::fs::File;
use std::io;
use std::io::Write;
use std::io::*;

fn main() -> io::Result<()> {
    let args = clap_app!(QueenGenerator =>
        (version: "0.1")
        (author: "Tim Beurskens")
        (about: "Generates n-queen formulae for the SAT solver")
        (@arg queens: -n --queens +takes_value "The number of queens")
        (@arg output: -o --output +takes_value "The output file")
    )
    .get_matches();

    let n = args
        .value_of("queens")
        .unwrap_or("4")
        .parse::<usize>()
        .expect("Invalid number of queens");

    let output = args.value_of("output");

    let mut writer = if output.is_some() {
        let file = File::create(output.unwrap())?;
        Box::new(BufWriter::new(file)) as Box<dyn Write>
    } else {
        Box::new(BufWriter::new(io::stdout())) as Box<dyn Write>
    };

    writeln!(writer, "\"Generated by n-queens-gen {}\"", n)?;
    writeln!(writer)?;

    writeln!(
        writer,
        "\"every diagonal must contain at most one queen (direction 1)\""
    )?;

    for i in 0..n {
        write!(writer, "[")?;
        for j in 0..(n - i) {
            write!(writer, "v_{},", i + (j * (n + 1)))?;
        }
        writeln!(writer, "] <= 1 &")?;
    }

    writeln!(writer)?;

    for i in 1..n {
        write!(writer, "[")?;
        for j in 0..(n - i) {
            write!(writer, "v_{},", (i * n) + (j * (n + 1)))?;
        }
        writeln!(writer, "] <= 1 &")?;
    }

    writeln!(writer)?;
    writeln!(
        writer,
        "\"every diagonal must contain at most one queen (direction 2)\""
    )?;

    for i in 0..n {
        write!(writer, "[")?;
        for j in 0..=i {
            write!(writer, "v_{},", i + (j * (n - 1)))?;
        }
        writeln!(writer, "] <= 1 &")?;
    }

    writeln!(writer)?;

    for i in 1..n {
        write!(writer, "[")?;
        for j in 0..i {
            write!(writer, "v_{},", n * (n - j) - (i - j))?;
        }
        writeln!(writer, "] <= 1 &")?;
    }

    writeln!(writer)?;

    writeln!(writer, "\"every row must contain exactly one queen\"")?;

    for i in 0..n {
        write!(writer, "[")?;
        for j in 0..n {
            write!(writer, "v_{},", j + i * n)?;
        }
        writeln!(writer, "] = 1 &")?;
    }

    writeln!(writer)?;
    writeln!(writer, "\"every column must contain exactly one queen\"")?;

    for i in 0..n {
        write!(writer, "[")?;
        for j in 0..n {
            write!(writer, "v_{},", i + j * n)?;
        }
        writeln!(writer, "] = 1 &")?;
    }

    writeln!(writer)?;

    writeln!(writer, "\"end\"")?;
    writeln!(writer, "true")?;

    // flush the writer before dropping it
    writer.flush().expect("Could not flush write buffer");

    Ok(())
}
