use std::fs::File;
use std::io;
use std::io::prelude::*;
use std::io::Write;
use std::io::*;
use std::path::PathBuf;

use clap::Parser;
use rustc_hash::FxHashSet;

#[derive(Parser, Debug)]
#[clap(author, version, about, long_about = None)]
struct Args {
    #[clap(value_parser, value_name = "INPUT")]
    /// Input file graph in csv edge-list format
    input: Option<PathBuf>,

    #[clap(value_parser, value_name = "OUTPUT")]
    /// The output rsbdd file
    output: Option<PathBuf>,

    #[clap(short, long)]
    /// Use undirected edges (test for both directions in the set-complement operation)
    undirected: bool,

    #[clap(short, long)]
    /// Construct a satisfiable formula for all cliques
    all: bool,
}

fn main() -> Result<()> {
    let version = env!("CARGO_PKG_VERSION");
    let args = Args::parse();

    let reader = if args.input.is_some() {
        let file = File::open(args.input.unwrap())?;
        Box::new(BufReader::new(file)) as Box<dyn BufRead>
    } else {
        Box::new(BufReader::new(io::stdin())) as Box<dyn BufRead>
    };

    let mut csv_reader = csv::ReaderBuilder::new()
        .has_headers(false)
        .from_reader(reader);

    let mut edges: Vec<(String, String)> = Vec::new();
    let mut vertices: FxHashSet<String> = FxHashSet::default();

    for edge_record in csv_reader.records() {
        let edge = edge_record?;

        assert_eq!(edge.len(), 2);

        edges.push((edge[0].to_string(), edge[1].to_string()));
        vertices.insert(edge[0].to_string());
        vertices.insert(edge[1].to_string());
    }

    let mut edges_complement: Vec<(String, String)> = Vec::new();

    let is_undirected: bool = args.undirected;
    let show_all: bool = args.all;

    for v1 in &vertices {
        for v2 in &vertices {
            if v1 != v2 {
                if is_undirected {
                    if !(edges.contains(&(v1.to_string(), v2.to_string()))
                        || edges.contains(&(v2.to_string(), v1.to_string()))
                        || edges_complement.contains(&(v2.to_string(), v1.to_string())))
                    {
                        edges_complement.push((v1.to_string(), v2.to_string()));
                    }
                } else if !edges.contains(&(v1.to_string(), v2.to_string())) {
                    edges_complement.push((v1.to_string(), v2.to_string()));
                }
            }
        }
    }

    let mut writer = if args.output.is_some() {
        let file = File::create(args.output.unwrap())?;
        Box::new(BufWriter::new(file)) as Box<dyn Write>
    } else {
        Box::new(BufWriter::new(io::stdout())) as Box<dyn Write>
    };

    writeln!(
        writer,
        "\"Generated by max-clique-gen version {}\"",
        version
    )?;
    writeln!(writer)?;

    writeln!(
        writer,
        "\"Property: if two vertices are in a clique, then they should be connected.\""
    )?;
    writeln!(
        writer,
        "\"Property: if two vertices are not connected, they cannot be in the same clique.\""
    )?;
    writeln!(writer)?;

    if edges_complement.is_empty() {
        writeln!(writer, "true &")?;
    } else {
        for complement in &edges_complement {
            writeln!(writer, "-({} & {}) &", complement.0, complement.1)?;
        }
    }

    writeln!(writer)?;

    if show_all {
        writeln!(writer, "true")?;
    } else {
        writeln!(writer, "\"No larger clique exists (every other clique is at most as big as the clique defined above)\"")?;
        writeln!(writer)?;

        writeln!(
            writer,
            "forall {} # (",
            vertices
                .iter()
                .map(|v| format!("v_{}", v))
                .collect::<Vec<String>>()
                .join(", ")
        )?;

        writeln!(
            writer,
            "{}",
            if edges_complement.is_empty() {
                "  true".to_string()
            } else {
                edges_complement
                    .iter()
                    .map(|(from, to)| format!("  -(v_{} & v_{})", from, to))
                    .collect::<Vec<String>>()
                    .join(" &\n")
            }
        )?;

        writeln!(
            writer,
            ") => [{}] >= [{}]",
            vertices.iter().cloned().collect::<Vec<String>>().join(", "),
            vertices
                .iter()
                .map(|v| format!("v_{}", v))
                .collect::<Vec<String>>()
                .join(", ")
        )?;
    }

    // flush the writer before dropping it
    writer.flush()?;

    Ok(())
}
