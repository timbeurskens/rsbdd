use clap::Parser;
use no_panic::no_panic;

use std::fs::File;
use std::io;
use std::io::Write;
use std::io::*;

use std::path::PathBuf;

#[derive(Parser, Debug)]
#[clap(author, version, about = "Generates n-queen formulae for the SAT solver", long_about = None)]
struct Args {
    #[clap(value_parser, value_name = "OUTPUT")]
    /// The output rsbdd file
    output: Option<PathBuf>,

    #[clap(short = 'n', long, value_parser, default_value_t = 4)]
    /// The number of queens
    queens: u16,
}

fn main() -> io::Result<()> {
    let version = env!("CARGO_PKG_VERSION");

    let args = Args::parse();

    let n = args.queens;

    let mut writer = if args.output.is_some() {
        let file = File::create(
            args.output
                .ok_or(io::Error::new(ErrorKind::NotFound, "output is None"))?,
        )?;
        Box::new(BufWriter::new(file)) as Box<dyn Write>
    } else {
        Box::new(BufWriter::new(io::stdout())) as Box<dyn Write>
    };

    writeln!(
        writer,
        "\"Generated by n-queens-gen version {} queens={} \"",
        version, n
    )?;
    writeln!(writer)?;

    writeln!(
        writer,
        "\"every diagonal must contain at most one queen (direction 1)\""
    )?;

    for i in 0..n {
        write!(writer, "[")?;
        for j in 0..(n - i) {
            write!(writer, "v_{},", i + (j * (n + 1)))?;
        }
        writeln!(writer, "] <= 1 &")?;
    }

    writeln!(writer)?;

    for i in 1..n {
        write!(writer, "[")?;
        for j in 0..(n - i) {
            write!(writer, "v_{},", (i * n) + (j * (n + 1)))?;
        }
        writeln!(writer, "] <= 1 &")?;
    }

    writeln!(writer)?;
    writeln!(
        writer,
        "\"every diagonal must contain at most one queen (direction 2)\""
    )?;

    for i in 0..n {
        write!(writer, "[")?;
        for j in 0..=i {
            write!(writer, "v_{},", i + (j * (n - 1)))?;
        }
        writeln!(writer, "] <= 1 &")?;
    }

    writeln!(writer)?;

    for i in 1..n {
        write!(writer, "[")?;
        for j in 0..i {
            write!(writer, "v_{},", n * (n - j) - (i - j))?;
        }
        writeln!(writer, "] <= 1 &")?;
    }

    writeln!(writer)?;

    writeln!(writer, "\"every row must contain exactly one queen\"")?;

    for i in 0..n {
        write!(writer, "[")?;
        for j in 0..n {
            write!(writer, "v_{},", j + i * n)?;
        }
        writeln!(writer, "] = 1 &")?;
    }

    writeln!(writer)?;
    writeln!(writer, "\"every column must contain exactly one queen\"")?;

    for i in 0..n {
        write!(writer, "[")?;
        for j in 0..n {
            write!(writer, "v_{},", i + j * n)?;
        }
        writeln!(writer, "] = 1 &")?;
    }

    writeln!(writer)?;

    writeln!(writer, "\"end\"")?;
    writeln!(writer, "true")?;

    // flush the writer before dropping it
    writer.flush()?;

    Ok(())
}
